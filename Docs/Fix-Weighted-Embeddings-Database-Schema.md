# Fix: Category and Content Embeddings Now Stored in Database

## Problem
Category and content embeddings were being generated by `VectorMemoryPersistenceService.SaveFragmentsAsync` but were **NOT** being saved to the database. The `CategoryEmbedding` and `ContentEmbedding` columns were missing from the database schema.

## Root Cause
The `VectorMemoryRepository` class was missing the `CategoryEmbedding` and `ContentEmbedding` columns in:
1. Table creation SQL (`CreateTableAsync`)
2. Schema initialization SQL (`InitializeDatabaseAsync`) 
3. INSERT statements (`SaveAsync`, `BulkSaveAsync`)
4. SELECT statements (all Load methods)

Even though the code was **generating** all three embeddings correctly, Dapper was silently ignoring the `CategoryEmbedding` and `ContentEmbedding` properties because those columns didn't exist in the database.

## Solution Applied

### 1. Updated Database Schema
Added `CategoryEmbedding` and `ContentEmbedding` columns to all table creation methods:

```sql
CREATE TABLE [MemoryFragments] (
    -- ...existing columns...
    Embedding VARBINARY(MAX) NULL,
    CategoryEmbedding VARBINARY(MAX) NULL,      -- NEW
    ContentEmbedding VARBINARY(MAX) NULL,       -- NEW
    EmbeddingDimension INT NULL,
    -- ...rest of columns...
);
```

### 2. Updated Migration Logic
Added automatic migration in `InitializeDatabaseAsync` to add columns to existing tables:

```sql
-- Add CategoryEmbedding column if it doesn't exist
IF NOT EXISTS (SELECT * FROM sys.columns 
    WHERE object_id = OBJECT_ID('MemoryFragments') 
    AND name = 'CategoryEmbedding')
BEGIN
    ALTER TABLE [MemoryFragments] ADD CategoryEmbedding VARBINARY(MAX) NULL;
END;

-- Add ContentEmbedding column if it doesn't exist
IF NOT EXISTS (SELECT * FROM sys.columns 
    WHERE object_id = OBJECT_ID('MemoryFragments') 
    AND name = 'ContentEmbedding')
BEGIN
    ALTER TABLE [MemoryFragments] ADD ContentEmbedding VARBINARY(MAX) NULL;
END;
```

### 3. Updated INSERT Statements
Modified `SaveAsync` and `BulkSaveAsync` to include new columns:

```sql
INSERT INTO [MemoryFragments] 
    (Id, ..., Embedding, CategoryEmbedding, ContentEmbedding, ...)
VALUES 
    (@Id, ..., @Embedding, @CategoryEmbedding, @ContentEmbedding, ...)
```

### 4. Updated SELECT Statements
Modified all Load methods to retrieve new columns:
- `LoadByCollectionAsync`
- `LoadByCollectionAndDomainsAsync`
- `LoadByCollectionPagedAsync`

```sql
SELECT Id, ..., Embedding, CategoryEmbedding, ContentEmbedding, ...
FROM [MemoryFragments]
WHERE ...
```

## Files Modified
1. `Infrastructure.Data.Dapper\VectorMemoryRepository.cs`
   - `CreateTableAsync` - Added columns to CREATE TABLE statement
   - `InitializeDatabaseAsync` - Added migration logic and columns
   - `SaveAsync` - Added columns to INSERT statement
   - `BulkSaveAsync` - Added columns to INSERT statement
   - `LoadByCollectionAsync` - Added columns to SELECT statement
   - `LoadByCollectionAndDomainsAsync` - Added columns to SELECT statement
   - `LoadByCollectionPagedAsync` - Added columns to SELECT statement

2. `Docs\Add-Weighted-Embedding-Columns.sql` (NEW)
   - Standalone migration script for existing databases
   - Can be run manually if needed

## What Happens Next

### For New Tables
New tables created via `CreateTableAsync` or `InitializeDatabaseAsync` will automatically include the `CategoryEmbedding` and `ContentEmbedding` columns.

### For Existing Tables
When you run the application:
1. `InitializeDatabaseAsync` will detect missing columns
2. Automatically run `ALTER TABLE` to add them
3. Existing rows will have `NULL` for these columns

### For Existing Data
Existing fragments will have `NULL` for `CategoryEmbedding` and `ContentEmbedding`. The weighted similarity algorithm in `DatabaseVectorMemory` already handles this gracefully:

```csharp
if (!categoryEmb.IsEmpty || !contentEmb.IsEmpty)
{
    // Use weighted similarity
    score = VectorExtensions.WeightedCosineSimilarity(...);
}
else if (!combinedEmb.IsEmpty)
{
    // Fallback to combined embedding only (legacy)
    score = queryEmbedding.CosineSimilarityWithNormalization(combinedEmb);
}
```

### To Get Full Weighted Embeddings
To populate the new columns for existing fragments:
1. Use `/regenerate` command in the CLI
2. Or manually:
   - Delete the collection: `DELETE FROM MemoryFragments WHERE CollectionName = 'your-collection'`
   - Move files from archive back to inbox
   - Restart the application

## Verification
After running the application or migration script, verify the columns exist:

```sql
SELECT 
    c.name as ColumnName,
    t.name as DataType,
    CASE WHEN c.is_nullable = 1 THEN 'YES' ELSE 'NO' END as IsNullable
FROM sys.columns c
INNER JOIN sys.types t ON c.user_type_id = t.user_type_id
WHERE c.object_id = OBJECT_ID('MemoryFragments')
AND c.name IN ('Embedding', 'CategoryEmbedding', 'ContentEmbedding')
ORDER BY c.name;
```

Expected output:
```
ColumnName          DataType    IsNullable
-----------------   ---------   ----------
CategoryEmbedding   varbinary   YES
ContentEmbedding    varbinary   YES
Embedding           varbinary   YES
```

## Benefits
? **Category-focused queries** - 40% weight on category matching for domain/topic queries  
? **Content-focused queries** - 30% weight on content matching for detail queries  
? **Balanced queries** - 30% weight on combined embedding for overall relevance  
? **Backward compatible** - Existing fragments with NULL still work via fallback  
? **Automatic migration** - No manual intervention needed for existing databases  

## Status
? **FIXED** - All code changes applied and build successful  
? **TESTED** - Build verification passed  
?? **ACTION REQUIRED** - Restart application to trigger migration OR run SQL script manually
